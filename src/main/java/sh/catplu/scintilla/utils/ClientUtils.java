package sh.catplu.scintilla.utils;


import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.texture.TextureAtlas;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.client.resources.model.BakedModel;
import net.minecraft.client.resources.model.ModelResourceLocation;
import net.minecraft.core.Direction;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.util.RandomSource;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.ModelEvent;
import net.minecraftforge.client.event.TextureStitchEvent;
import net.minecraftforge.client.model.data.ModelData;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import sh.catplu.scintilla.model.BakedScintilla;

import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

@Mod.EventBusSubscriber(modid = "scintilla", bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT) // IMPORTANT: value = Dist.CLIENT
public class ClientUtils {

    // This will store the function that maps ResourceLocation to TextureAtlasSprite
    private static Function<ResourceLocation, TextureAtlasSprite> spriteGetter;

    // This event is fired AFTER the texture atlas has loaded all textures and stitched them together.
    @SubscribeEvent
    public static void onTextureStitch(TextureStitchEvent.Post event) {
        if (event.getAtlas().location().equals(TextureAtlas.LOCATION_BLOCKS)) {
            spriteGetter = event.getAtlas()::getSprite;
            System.out.println("Captured sprite getter for blocks atlas!"); // Optional logging
        }
    }

    /**
     * Gets a TextureAtlasSprite from its ResourceLocation.
     * This method can be called from your custom ItemOverrides.
     *
     * @param location The ResourceLocation of the texture.
     * @return The TextureAtlasSprite, or null if not found or if called before stitching.
     */
    @SuppressWarnings("removal")
    public static TextureAtlasSprite getSprite(ResourceLocation location) {
        if (spriteGetter != null) {
            return spriteGetter.apply(location);
        }
        // It's crucial that this helper is only called AFTER the atlas is stitched.
        // If it's called too early (before onTextureStitch fires), spriteGetter will be null.
        // You might want to log a warning or return a default missing texture sprite in a real mod.
        System.err.println("Attempted to get sprite before atlas was stitched: " + location);
        return Minecraft.getInstance().getTextureAtlas(TextureAtlas.LOCATION_BLOCKS).apply(new ResourceLocation("missingno"));
    }

    @SubscribeEvent
    public static void onModifyBakingResult(ModelEvent.ModifyBakingResult event) {
        // Get the ResourceLocation of your item model
        ResourceLocation itemModelLocation = new ModelResourceLocation("scintilla", "scintilla", "inventory"); // Replace with your item's name

        // Get the baked model that was generated by the vanilla model loader
        Map<ResourceLocation, BakedModel> modelRegistry = event.getModels();
        BakedModel originalBakedModel = modelRegistry.get(itemModelLocation);

        if (originalBakedModel != null) {
            // --- 1. Get the General Quads ---
            List<BakedQuad> generalQuads = originalBakedModel.getQuads(null, null, RandomSource.create(0), ModelData.EMPTY, null);

            // --- 2. Get the Culled Faces Map ---
            Map<Direction, List<BakedQuad>> culledFaces = new EnumMap<>(Direction.class);
            for (Direction direction : Direction.values()) {
                List<BakedQuad> quadsForDirection = originalBakedModel.getQuads(null, direction, RandomSource.create(0), ModelData.EMPTY, null);
                if (!quadsForDirection.isEmpty()) {
                    culledFaces.put(direction, quadsForDirection);
                }
            }

            // --- 3. Create an instance of your custom BakedModel ---
            BakedScintilla customBakedModel = new BakedScintilla(
                    generalQuads,                         // General quads
                    culledFaces,                          // Map of culled faces (second argument)
                    originalBakedModel.useAmbientOcclusion(),
                    originalBakedModel.isGui3d(),
                    originalBakedModel.usesBlockLight(),  // Uses block light
                    originalBakedModel.getParticleIcon(),
                    originalBakedModel.getTransforms(),
                    originalBakedModel.getOverrides()     // Pass the original overrides (likely ItemOverrides.EMPTY)
                    // You must ensure YourCustomBakedModel handles this correctly
            );

            // Replace the original baked model with your custom baked model
            event.getModels().put(itemModelLocation, customBakedModel);

            System.out.println("Replaced baked model for your_item_name with custom model.");
        } else {
            System.err.println("Could not find baked model for your_item_name during BakingCompleted event.");
        }
    }
}